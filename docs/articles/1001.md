# Подстановка в текст вопроса ответов из предыдущих вопросов

 Часто возникает необходимость в текст вопроса (или в комментарий оператору) подставить выбранный вариант ответа из предыдущего вопроса. Например ситуация:

> Q1: Какой продуктовый магазин Вы посещаете чаще всего?
>
> 1 - Магазин А<br>
> 2 - Магазин Б<br>
> 3 - Магазин В<br>
>
> Q2: Почему Вы так любите магазин _ ?

Допустим вопрос Q1 - единственный выбор, и мы хотим в Q2 подставить название выбранного магазина. Делается это просто. В вопросе Q2 в тексте указываем вместо прочерков - имя переменной, в которую запишем выбранный магазин:

> Q2: Почему Вы так любите магазин {magaz}?

Теперь пишем в скрипт перед показом для вопроса Q2 следующее:

```js
if (Q1.isAnswered) {
    V['magaz'] = Q1.getChecked()[0].text;
} else {
    V['magaz'] = '!ОШИБКА!';
}
```

Т.е. мы сначала проверяем, на всякий случай, что вопрос Q1 отвечен, и если это так - в глобальную переменную `magaz` записываем текст выбранного варианта ответа из Q1.

Единожды присвоенное значение глобальной переменной можно использовать и дальше, в следующих вопросах. Т.е. и в каком-нибудь Q3 можно спросить что-то про тот же `{magaz}`, не прописывая в него скриптов.

Думаю, у многих возникнет закономерный вопрос - а что делать, если в списке вариантов ответа есть открытое значение, и далее нам надо спросить именно про то, что написал оператор в этом поле? Усложняем наши вопросы:

> Q1: Какой продуктовый магазин Вы посещаете чаще всего?
>
> 1 - Магазин А<br>
> 2 - Магазин Б<br>
> 3 - Магазин Ц<br>
> 98 - Другое (ЗАПИШИТЕ)<br>
>
> Q2: Почему Вы так любите магазин {magaz}?

Т.е. получается, что если выбраны коды 1,2,3 - то всё по прежнему, а если 98 - тут надо взять не текст варианта ответа, а введенное открытое значение. Меняем скрипт перед показом для Q2 следующим образом:

```js
if (Q1.isAnswered) {
    let A = Q1.getChecked()[0];
    V['magaz'] = (A.code == 98) ? A.openValueTxt : A.text;
} else {
    V['magaz'] = '!ОШИБКА!';
}
```

Т.е. для удобства, сначала в переменную `A` мы получаем выбранный вариант ответа из Q1, а далее, если код этого варианта ответа 98 - берем его открытое значение из свойства `openValueTxt`, а если любой другой код, то просто `text`.

Бывают случаи, когда вопрос Q1 предполагает несколько ответов, а указанные выше скрипты выводят только один выбранный ответ – некорректно. Чтобы в Q2 отображались все выбранные в Q1 ответы, нужно использовать цикл:

```js
if (Q1.isAnswered) {
    let s = '';

    for (let A of Q1.getChecked()) {
        s += s.length > 0 ? ', ' : '';
        s += A.flags & AnswerFlags.OpenValueTxt ? A.openValueTxt : A.text;
    }

    V['magaz'] = s;
} else {
    V['magaz'] = '!ОШИБКА!';
}
```

Т.е. проходим в цикле по всем выбранным в Q1 ответам, добавляя через запятую их тексты в переменную `s`, а затем помещаем результат в глобальную переменную `magaz`. Вместо проверки кода 98 здесь используется более универсальный вариант – проверка наличия у ответа текстового поля: если оно есть – берём текст из него, если нет – берём текст варианта ответа.

Для подстановки значений из полей ввода существуют стандартные подстановки:

- _{Q1}_ – текст или число из простого текстового или числового вопроса.
- _{Q2.1N}_ – число из числового поля ответа 1, если вопрос с выбором, или из числового поля у строки 1, если вопрос табличный.
- _{Q2.98T}_ – текст из текстового поля ответа 98, если вопрос с выбором, или из текстового поля у строки 98, если вопрос табличный.
- _{Q3.1}_ – текст или число ответа в строке 1 табличного текстового или числового вопроса.
- _{Q4.1.2N}_ – число из числового поля ответа 2 в строке 1 табличного вопроса с выбором.
- _{Q4.2.98T}_ – текст из текстового поля ответа 98 в строке 2 табличного вопроса с выбором.
